// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mediapipe/calculators/tflite/ssd_anchors_calculator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mediapipe {

  /// <summary>Holder for reflection information generated from mediapipe/calculators/tflite/ssd_anchors_calculator.proto</summary>
  public static partial class SsdAnchorsCalculatorReflection {

    #region Descriptor
    /// <summary>File descriptor for mediapipe/calculators/tflite/ssd_anchors_calculator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static SsdAnchorsCalculatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjltZWRpYXBpcGUvY2FsY3VsYXRvcnMvdGZsaXRlL3NzZF9hbmNob3JzX2Nh",
            "bGN1bGF0b3IucHJvdG8SCW1lZGlhcGlwZRokbWVkaWFwaXBlL2ZyYW1ld29y",
            "ay9jYWxjdWxhdG9yLnByb3RvIvgDChtTc2RBbmNob3JzQ2FsY3VsYXRvck9w",
            "dGlvbnMSGAoQaW5wdXRfc2l6ZV93aWR0aBgBIAEoBRIZChFpbnB1dF9zaXpl",
            "X2hlaWdodBgCIAEoBRIRCgltaW5fc2NhbGUYAyABKAISEQoJbWF4X3NjYWxl",
            "GAQgASgCEhwKD2FuY2hvcl9vZmZzZXRfeBgFIAEoAjoDMC41EhwKD2FuY2hv",
            "cl9vZmZzZXRfeRgGIAEoAjoDMC41EhIKCm51bV9sYXllcnMYByABKAUSGQoR",
            "ZmVhdHVyZV9tYXBfd2lkdGgYCCADKAUSGgoSZmVhdHVyZV9tYXBfaGVpZ2h0",
            "GAkgAygFEg8KB3N0cmlkZXMYCiADKAUSFQoNYXNwZWN0X3JhdGlvcxgLIAMo",
            "AhIrChxyZWR1Y2VfYm94ZXNfaW5fbG93ZXN0X2xheWVyGAwgASgIOgVmYWxz",
            "ZRIqCh9pbnRlcnBvbGF0ZWRfc2NhbGVfYXNwZWN0X3JhdGlvGA0gASgCOgEx",
            "EiAKEWZpeGVkX2FuY2hvcl9zaXplGA4gASgIOgVmYWxzZTJUCgNleHQSHC5t",
            "ZWRpYXBpcGUuQ2FsY3VsYXRvck9wdGlvbnMY/7jzdSABKAsyJi5tZWRpYXBp",
            "cGUuU3NkQW5jaG9yc0NhbGN1bGF0b3JPcHRpb25z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mediapipe.CalculatorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mediapipe.SsdAnchorsCalculatorOptions), global::Mediapipe.SsdAnchorsCalculatorOptions.Parser, new[]{ "InputSizeWidth", "InputSizeHeight", "MinScale", "MaxScale", "AnchorOffsetX", "AnchorOffsetY", "NumLayers", "FeatureMapWidth", "FeatureMapHeight", "Strides", "AspectRatios", "ReduceBoxesInLowestLayer", "InterpolatedScaleAspectRatio", "FixedAnchorSize" }, null, null, new pb::Extension[] { global::Mediapipe.SsdAnchorsCalculatorOptions.Extensions.Ext }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Options to generate anchors for SSD object detection models.
  /// </summary>
  public sealed partial class SsdAnchorsCalculatorOptions : pb::IMessage<SsdAnchorsCalculatorOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SsdAnchorsCalculatorOptions> _parser = new pb::MessageParser<SsdAnchorsCalculatorOptions>(() => new SsdAnchorsCalculatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SsdAnchorsCalculatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mediapipe.SsdAnchorsCalculatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SsdAnchorsCalculatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SsdAnchorsCalculatorOptions(SsdAnchorsCalculatorOptions other) : this() {
      _hasBits0 = other._hasBits0;
      inputSizeWidth_ = other.inputSizeWidth_;
      inputSizeHeight_ = other.inputSizeHeight_;
      minScale_ = other.minScale_;
      maxScale_ = other.maxScale_;
      anchorOffsetX_ = other.anchorOffsetX_;
      anchorOffsetY_ = other.anchorOffsetY_;
      numLayers_ = other.numLayers_;
      featureMapWidth_ = other.featureMapWidth_.Clone();
      featureMapHeight_ = other.featureMapHeight_.Clone();
      strides_ = other.strides_.Clone();
      aspectRatios_ = other.aspectRatios_.Clone();
      reduceBoxesInLowestLayer_ = other.reduceBoxesInLowestLayer_;
      interpolatedScaleAspectRatio_ = other.interpolatedScaleAspectRatio_;
      fixedAnchorSize_ = other.fixedAnchorSize_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SsdAnchorsCalculatorOptions Clone() {
      return new SsdAnchorsCalculatorOptions(this);
    }

    /// <summary>Field number for the "input_size_width" field.</summary>
    public const int InputSizeWidthFieldNumber = 1;
    private readonly static int InputSizeWidthDefaultValue = 0;

    private int inputSizeWidth_;
    /// <summary>
    /// Size of input images.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InputSizeWidth {
      get { if ((_hasBits0 & 1) != 0) { return inputSizeWidth_; } else { return InputSizeWidthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        inputSizeWidth_ = value;
      }
    }
    /// <summary>Gets whether the "input_size_width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInputSizeWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "input_size_width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInputSizeWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "input_size_height" field.</summary>
    public const int InputSizeHeightFieldNumber = 2;
    private readonly static int InputSizeHeightDefaultValue = 0;

    private int inputSizeHeight_;
    /// <summary>
    /// required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InputSizeHeight {
      get { if ((_hasBits0 & 2) != 0) { return inputSizeHeight_; } else { return InputSizeHeightDefaultValue; } }
      set {
        _hasBits0 |= 2;
        inputSizeHeight_ = value;
      }
    }
    /// <summary>Gets whether the "input_size_height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInputSizeHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "input_size_height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInputSizeHeight() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "min_scale" field.</summary>
    public const int MinScaleFieldNumber = 3;
    private readonly static float MinScaleDefaultValue = 0F;

    private float minScale_;
    /// <summary>
    /// Min and max scales for generating anchor boxes on feature maps.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MinScale {
      get { if ((_hasBits0 & 4) != 0) { return minScale_; } else { return MinScaleDefaultValue; } }
      set {
        _hasBits0 |= 4;
        minScale_ = value;
      }
    }
    /// <summary>Gets whether the "min_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinScale {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "min_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinScale() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "max_scale" field.</summary>
    public const int MaxScaleFieldNumber = 4;
    private readonly static float MaxScaleDefaultValue = 0F;

    private float maxScale_;
    /// <summary>
    /// required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float MaxScale {
      get { if ((_hasBits0 & 8) != 0) { return maxScale_; } else { return MaxScaleDefaultValue; } }
      set {
        _hasBits0 |= 8;
        maxScale_ = value;
      }
    }
    /// <summary>Gets whether the "max_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxScale {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "max_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxScale() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "anchor_offset_x" field.</summary>
    public const int AnchorOffsetXFieldNumber = 5;
    private readonly static float AnchorOffsetXDefaultValue = 0.5F;

    private float anchorOffsetX_;
    /// <summary>
    /// The offset for the center of anchors. The value is in the scale of stride.
    /// E.g. 0.5 meaning 0.5 * |current_stride| in pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AnchorOffsetX {
      get { if ((_hasBits0 & 16) != 0) { return anchorOffsetX_; } else { return AnchorOffsetXDefaultValue; } }
      set {
        _hasBits0 |= 16;
        anchorOffsetX_ = value;
      }
    }
    /// <summary>Gets whether the "anchor_offset_x" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnchorOffsetX {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "anchor_offset_x" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnchorOffsetX() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "anchor_offset_y" field.</summary>
    public const int AnchorOffsetYFieldNumber = 6;
    private readonly static float AnchorOffsetYDefaultValue = 0.5F;

    private float anchorOffsetY_;
    /// <summary>
    /// required
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float AnchorOffsetY {
      get { if ((_hasBits0 & 32) != 0) { return anchorOffsetY_; } else { return AnchorOffsetYDefaultValue; } }
      set {
        _hasBits0 |= 32;
        anchorOffsetY_ = value;
      }
    }
    /// <summary>Gets whether the "anchor_offset_y" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAnchorOffsetY {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "anchor_offset_y" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAnchorOffsetY() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "num_layers" field.</summary>
    public const int NumLayersFieldNumber = 7;
    private readonly static int NumLayersDefaultValue = 0;

    private int numLayers_;
    /// <summary>
    /// Number of output feature maps to generate the anchors on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NumLayers {
      get { if ((_hasBits0 & 64) != 0) { return numLayers_; } else { return NumLayersDefaultValue; } }
      set {
        _hasBits0 |= 64;
        numLayers_ = value;
      }
    }
    /// <summary>Gets whether the "num_layers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumLayers {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "num_layers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumLayers() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "feature_map_width" field.</summary>
    public const int FeatureMapWidthFieldNumber = 8;
    private static readonly pb::FieldCodec<int> _repeated_featureMapWidth_codec
        = pb::FieldCodec.ForInt32(64);
    private readonly pbc::RepeatedField<int> featureMapWidth_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Sizes of output feature maps to create anchors. Either feature_map size or
    /// stride should be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> FeatureMapWidth {
      get { return featureMapWidth_; }
    }

    /// <summary>Field number for the "feature_map_height" field.</summary>
    public const int FeatureMapHeightFieldNumber = 9;
    private static readonly pb::FieldCodec<int> _repeated_featureMapHeight_codec
        = pb::FieldCodec.ForInt32(72);
    private readonly pbc::RepeatedField<int> featureMapHeight_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> FeatureMapHeight {
      get { return featureMapHeight_; }
    }

    /// <summary>Field number for the "strides" field.</summary>
    public const int StridesFieldNumber = 10;
    private static readonly pb::FieldCodec<int> _repeated_strides_codec
        = pb::FieldCodec.ForInt32(80);
    private readonly pbc::RepeatedField<int> strides_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Strides of each output feature maps.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> Strides {
      get { return strides_; }
    }

    /// <summary>Field number for the "aspect_ratios" field.</summary>
    public const int AspectRatiosFieldNumber = 11;
    private static readonly pb::FieldCodec<float> _repeated_aspectRatios_codec
        = pb::FieldCodec.ForFloat(93);
    private readonly pbc::RepeatedField<float> aspectRatios_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// List of different aspect ratio to generate anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<float> AspectRatios {
      get { return aspectRatios_; }
    }

    /// <summary>Field number for the "reduce_boxes_in_lowest_layer" field.</summary>
    public const int ReduceBoxesInLowestLayerFieldNumber = 12;
    private readonly static bool ReduceBoxesInLowestLayerDefaultValue = false;

    private bool reduceBoxesInLowestLayer_;
    /// <summary>
    /// A boolean to indicate whether the fixed 3 boxes per location is used in the
    /// lowest layer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReduceBoxesInLowestLayer {
      get { if ((_hasBits0 & 128) != 0) { return reduceBoxesInLowestLayer_; } else { return ReduceBoxesInLowestLayerDefaultValue; } }
      set {
        _hasBits0 |= 128;
        reduceBoxesInLowestLayer_ = value;
      }
    }
    /// <summary>Gets whether the "reduce_boxes_in_lowest_layer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReduceBoxesInLowestLayer {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "reduce_boxes_in_lowest_layer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReduceBoxesInLowestLayer() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "interpolated_scale_aspect_ratio" field.</summary>
    public const int InterpolatedScaleAspectRatioFieldNumber = 13;
    private readonly static float InterpolatedScaleAspectRatioDefaultValue = 1F;

    private float interpolatedScaleAspectRatio_;
    /// <summary>
    /// An additional anchor is added with this aspect ratio and a scale
    /// interpolated between the scale for a layer and the scale for the next layer
    /// (1.0 for the last layer). This anchor is not included if this value is 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float InterpolatedScaleAspectRatio {
      get { if ((_hasBits0 & 256) != 0) { return interpolatedScaleAspectRatio_; } else { return InterpolatedScaleAspectRatioDefaultValue; } }
      set {
        _hasBits0 |= 256;
        interpolatedScaleAspectRatio_ = value;
      }
    }
    /// <summary>Gets whether the "interpolated_scale_aspect_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInterpolatedScaleAspectRatio {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "interpolated_scale_aspect_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInterpolatedScaleAspectRatio() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "fixed_anchor_size" field.</summary>
    public const int FixedAnchorSizeFieldNumber = 14;
    private readonly static bool FixedAnchorSizeDefaultValue = false;

    private bool fixedAnchorSize_;
    /// <summary>
    /// Whether use fixed width and height (e.g. both 1.0f) for each anchor.
    /// This option can be used when the predicted anchor width and height are in
    /// pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FixedAnchorSize {
      get { if ((_hasBits0 & 512) != 0) { return fixedAnchorSize_; } else { return FixedAnchorSizeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        fixedAnchorSize_ = value;
      }
    }
    /// <summary>Gets whether the "fixed_anchor_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFixedAnchorSize {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "fixed_anchor_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFixedAnchorSize() {
      _hasBits0 &= ~512;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SsdAnchorsCalculatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SsdAnchorsCalculatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InputSizeWidth != other.InputSizeWidth) return false;
      if (InputSizeHeight != other.InputSizeHeight) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinScale, other.MinScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxScale, other.MaxScale)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AnchorOffsetX, other.AnchorOffsetX)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AnchorOffsetY, other.AnchorOffsetY)) return false;
      if (NumLayers != other.NumLayers) return false;
      if(!featureMapWidth_.Equals(other.featureMapWidth_)) return false;
      if(!featureMapHeight_.Equals(other.featureMapHeight_)) return false;
      if(!strides_.Equals(other.strides_)) return false;
      if(!aspectRatios_.Equals(other.aspectRatios_)) return false;
      if (ReduceBoxesInLowestLayer != other.ReduceBoxesInLowestLayer) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InterpolatedScaleAspectRatio, other.InterpolatedScaleAspectRatio)) return false;
      if (FixedAnchorSize != other.FixedAnchorSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasInputSizeWidth) hash ^= InputSizeWidth.GetHashCode();
      if (HasInputSizeHeight) hash ^= InputSizeHeight.GetHashCode();
      if (HasMinScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinScale);
      if (HasMaxScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxScale);
      if (HasAnchorOffsetX) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AnchorOffsetX);
      if (HasAnchorOffsetY) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AnchorOffsetY);
      if (HasNumLayers) hash ^= NumLayers.GetHashCode();
      hash ^= featureMapWidth_.GetHashCode();
      hash ^= featureMapHeight_.GetHashCode();
      hash ^= strides_.GetHashCode();
      hash ^= aspectRatios_.GetHashCode();
      if (HasReduceBoxesInLowestLayer) hash ^= ReduceBoxesInLowestLayer.GetHashCode();
      if (HasInterpolatedScaleAspectRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InterpolatedScaleAspectRatio);
      if (HasFixedAnchorSize) hash ^= FixedAnchorSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasInputSizeWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(InputSizeWidth);
      }
      if (HasInputSizeHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(InputSizeHeight);
      }
      if (HasMinScale) {
        output.WriteRawTag(29);
        output.WriteFloat(MinScale);
      }
      if (HasMaxScale) {
        output.WriteRawTag(37);
        output.WriteFloat(MaxScale);
      }
      if (HasAnchorOffsetX) {
        output.WriteRawTag(45);
        output.WriteFloat(AnchorOffsetX);
      }
      if (HasAnchorOffsetY) {
        output.WriteRawTag(53);
        output.WriteFloat(AnchorOffsetY);
      }
      if (HasNumLayers) {
        output.WriteRawTag(56);
        output.WriteInt32(NumLayers);
      }
      featureMapWidth_.WriteTo(output, _repeated_featureMapWidth_codec);
      featureMapHeight_.WriteTo(output, _repeated_featureMapHeight_codec);
      strides_.WriteTo(output, _repeated_strides_codec);
      aspectRatios_.WriteTo(output, _repeated_aspectRatios_codec);
      if (HasReduceBoxesInLowestLayer) {
        output.WriteRawTag(96);
        output.WriteBool(ReduceBoxesInLowestLayer);
      }
      if (HasInterpolatedScaleAspectRatio) {
        output.WriteRawTag(109);
        output.WriteFloat(InterpolatedScaleAspectRatio);
      }
      if (HasFixedAnchorSize) {
        output.WriteRawTag(112);
        output.WriteBool(FixedAnchorSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasInputSizeWidth) {
        output.WriteRawTag(8);
        output.WriteInt32(InputSizeWidth);
      }
      if (HasInputSizeHeight) {
        output.WriteRawTag(16);
        output.WriteInt32(InputSizeHeight);
      }
      if (HasMinScale) {
        output.WriteRawTag(29);
        output.WriteFloat(MinScale);
      }
      if (HasMaxScale) {
        output.WriteRawTag(37);
        output.WriteFloat(MaxScale);
      }
      if (HasAnchorOffsetX) {
        output.WriteRawTag(45);
        output.WriteFloat(AnchorOffsetX);
      }
      if (HasAnchorOffsetY) {
        output.WriteRawTag(53);
        output.WriteFloat(AnchorOffsetY);
      }
      if (HasNumLayers) {
        output.WriteRawTag(56);
        output.WriteInt32(NumLayers);
      }
      featureMapWidth_.WriteTo(ref output, _repeated_featureMapWidth_codec);
      featureMapHeight_.WriteTo(ref output, _repeated_featureMapHeight_codec);
      strides_.WriteTo(ref output, _repeated_strides_codec);
      aspectRatios_.WriteTo(ref output, _repeated_aspectRatios_codec);
      if (HasReduceBoxesInLowestLayer) {
        output.WriteRawTag(96);
        output.WriteBool(ReduceBoxesInLowestLayer);
      }
      if (HasInterpolatedScaleAspectRatio) {
        output.WriteRawTag(109);
        output.WriteFloat(InterpolatedScaleAspectRatio);
      }
      if (HasFixedAnchorSize) {
        output.WriteRawTag(112);
        output.WriteBool(FixedAnchorSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasInputSizeWidth) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InputSizeWidth);
      }
      if (HasInputSizeHeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InputSizeHeight);
      }
      if (HasMinScale) {
        size += 1 + 4;
      }
      if (HasMaxScale) {
        size += 1 + 4;
      }
      if (HasAnchorOffsetX) {
        size += 1 + 4;
      }
      if (HasAnchorOffsetY) {
        size += 1 + 4;
      }
      if (HasNumLayers) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumLayers);
      }
      size += featureMapWidth_.CalculateSize(_repeated_featureMapWidth_codec);
      size += featureMapHeight_.CalculateSize(_repeated_featureMapHeight_codec);
      size += strides_.CalculateSize(_repeated_strides_codec);
      size += aspectRatios_.CalculateSize(_repeated_aspectRatios_codec);
      if (HasReduceBoxesInLowestLayer) {
        size += 1 + 1;
      }
      if (HasInterpolatedScaleAspectRatio) {
        size += 1 + 4;
      }
      if (HasFixedAnchorSize) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SsdAnchorsCalculatorOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasInputSizeWidth) {
        InputSizeWidth = other.InputSizeWidth;
      }
      if (other.HasInputSizeHeight) {
        InputSizeHeight = other.InputSizeHeight;
      }
      if (other.HasMinScale) {
        MinScale = other.MinScale;
      }
      if (other.HasMaxScale) {
        MaxScale = other.MaxScale;
      }
      if (other.HasAnchorOffsetX) {
        AnchorOffsetX = other.AnchorOffsetX;
      }
      if (other.HasAnchorOffsetY) {
        AnchorOffsetY = other.AnchorOffsetY;
      }
      if (other.HasNumLayers) {
        NumLayers = other.NumLayers;
      }
      featureMapWidth_.Add(other.featureMapWidth_);
      featureMapHeight_.Add(other.featureMapHeight_);
      strides_.Add(other.strides_);
      aspectRatios_.Add(other.aspectRatios_);
      if (other.HasReduceBoxesInLowestLayer) {
        ReduceBoxesInLowestLayer = other.ReduceBoxesInLowestLayer;
      }
      if (other.HasInterpolatedScaleAspectRatio) {
        InterpolatedScaleAspectRatio = other.InterpolatedScaleAspectRatio;
      }
      if (other.HasFixedAnchorSize) {
        FixedAnchorSize = other.FixedAnchorSize;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            InputSizeWidth = input.ReadInt32();
            break;
          }
          case 16: {
            InputSizeHeight = input.ReadInt32();
            break;
          }
          case 29: {
            MinScale = input.ReadFloat();
            break;
          }
          case 37: {
            MaxScale = input.ReadFloat();
            break;
          }
          case 45: {
            AnchorOffsetX = input.ReadFloat();
            break;
          }
          case 53: {
            AnchorOffsetY = input.ReadFloat();
            break;
          }
          case 56: {
            NumLayers = input.ReadInt32();
            break;
          }
          case 66:
          case 64: {
            featureMapWidth_.AddEntriesFrom(input, _repeated_featureMapWidth_codec);
            break;
          }
          case 74:
          case 72: {
            featureMapHeight_.AddEntriesFrom(input, _repeated_featureMapHeight_codec);
            break;
          }
          case 82:
          case 80: {
            strides_.AddEntriesFrom(input, _repeated_strides_codec);
            break;
          }
          case 90:
          case 93: {
            aspectRatios_.AddEntriesFrom(input, _repeated_aspectRatios_codec);
            break;
          }
          case 96: {
            ReduceBoxesInLowestLayer = input.ReadBool();
            break;
          }
          case 109: {
            InterpolatedScaleAspectRatio = input.ReadFloat();
            break;
          }
          case 112: {
            FixedAnchorSize = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            InputSizeWidth = input.ReadInt32();
            break;
          }
          case 16: {
            InputSizeHeight = input.ReadInt32();
            break;
          }
          case 29: {
            MinScale = input.ReadFloat();
            break;
          }
          case 37: {
            MaxScale = input.ReadFloat();
            break;
          }
          case 45: {
            AnchorOffsetX = input.ReadFloat();
            break;
          }
          case 53: {
            AnchorOffsetY = input.ReadFloat();
            break;
          }
          case 56: {
            NumLayers = input.ReadInt32();
            break;
          }
          case 66:
          case 64: {
            featureMapWidth_.AddEntriesFrom(ref input, _repeated_featureMapWidth_codec);
            break;
          }
          case 74:
          case 72: {
            featureMapHeight_.AddEntriesFrom(ref input, _repeated_featureMapHeight_codec);
            break;
          }
          case 82:
          case 80: {
            strides_.AddEntriesFrom(ref input, _repeated_strides_codec);
            break;
          }
          case 90:
          case 93: {
            aspectRatios_.AddEntriesFrom(ref input, _repeated_aspectRatios_codec);
            break;
          }
          case 96: {
            ReduceBoxesInLowestLayer = input.ReadBool();
            break;
          }
          case 109: {
            InterpolatedScaleAspectRatio = input.ReadFloat();
            break;
          }
          case 112: {
            FixedAnchorSize = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Extensions
    /// <summary>Container for extensions for other messages declared in the SsdAnchorsCalculatorOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Extensions {
      public static readonly pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.SsdAnchorsCalculatorOptions> Ext =
        new pb::Extension<global::Mediapipe.CalculatorOptions, global::Mediapipe.SsdAnchorsCalculatorOptions>(247258239, pb::FieldCodec.ForMessage(1978065914, global::Mediapipe.SsdAnchorsCalculatorOptions.Parser));
    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
